<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Orbital Period and Orbital Radius</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Escape Velocities and Cosmic Velocities</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<p>Let’s address the problem of calculating equivalent resistance using graph theory, focusing on <strong>Option 1: Simplified Task – Algorithm Description</strong>, as requested, and creating a project simulation in HTML, CSS, and JavaScript to visualize and interact with circuit graphs. I’ll provide a detailed explanation of the algorithm, pseudocode, and analysis for three example circuits, followed by a web-based simulation that allows users to build and simplify circuits to compute equivalent resistance. The CSS will be designed to be visually appealing with larger, bold styles for a beautiful interface.</p>
<hr/>
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<h2 id="introduction">Introduction</h2>
<p>Calculating the equivalent resistance of a circuit is a core problem in electrical engineering. Traditional methods rely on identifying series and parallel resistor combinations, but complex circuits with multiple nodes and cycles can be challenging to simplify manually. Graph theory offers a systematic approach by modeling a circuit as a graph, where nodes represent junctions and edges represent resistors with weights equal to their resistance values. This method enables iterative simplification of the graph to compute the equivalent resistance, even for intricate configurations.</p>
<p>The objectives are:
1. Describe an algorithm for calculating equivalent resistance using graph theory, including pseudocode.
2. Explain how the algorithm handles three example circuits: simple series, simple parallel, and a nested configuration.
3. Analyze the algorithm’s efficiency and suggest improvements.
4. Develop an interactive web-based simulation using HTML, CSS, and JavaScript to visualize circuit simplification and compute equivalent resistance.</p>
<h2 id="algorithm-description">Algorithm Description</h2>
<h3 id="graph-representation">Graph Representation</h3>
<p>A circuit is represented as an undirected weighted graph <span class="arithmatex">\( G = (V, E) \)</span>:
- <strong>Vertices (V)</strong>: Junctions or nodes where resistors connect.
- <strong>Edges (E)</strong>: Resistors connecting pairs of nodes, with weights equal to resistance values (in ohms, Ω).
- The goal is to find the equivalent resistance between two specified nodes, say <span class="arithmatex">\( s \)</span> (source) and <span class="arithmatex">\( t \)</span> (sink).</p>
<h3 id="algorithm-overview">Algorithm Overview</h3>
<p>The algorithm iteratively simplifies the graph by identifying and reducing series and parallel resistor combinations until only the source and sink nodes remain, connected by a single edge whose weight is the equivalent resistance. It uses graph traversal to detect patterns and applies resistance formulas:
- <strong>Series</strong>: Resistors <span class="arithmatex">\( R_1 \)</span> and <span class="arithmatex">\( R_2 \)</span> in series combine as <span class="arithmatex">\( R_{\text{eq}} = R_1 + R_2 \)</span>.
- <strong>Parallel</strong>: Resistors <span class="arithmatex">\( R_1 \)</span> and <span class="arithmatex">\( R_2 \)</span> in parallel combine as <span class="arithmatex">\( R_{\text{eq}} = \frac{R_1 R_2}{R_1 + R_2} \)</span>.</p>
<h3 id="pseudocode">Pseudocode</h3>
<pre><code>Algorithm ComputeEquivalentResistance(G, s, t)
    Input: Graph G = (V, E) with edge weights as resistances, source node s, sink node t
    Output: Equivalent resistance between s and t

    while |V| &gt; 2 or |E| &gt; 1 do
        // Step 1: Identify series connections
        for each node u in V do
            if degree(u) = 2 and u ≠ s and u ≠ t then
                let neighbors of u be v and w
                let R1 = resistance(u, v), R2 = resistance(u, w)
                // Remove node u and edges (u, v), (u, w)
                remove edge (u, v) from E
                remove edge (u, w) from E
                remove node u from V
                // Add new edge (v, w) with series resistance
                R_eq = R1 + R2
                add edge (v, w) with weight R_eq to E
                update graph G
            end if
        end for

        // Step 2: Identify parallel connections
        for each pair of nodes (u, v) in V do
            if multiple edges exist between u and v then
                let R1, R2, ..., Rk be resistances of parallel edges
                // Compute parallel equivalent
                R_eq = 1 / (1/R1 + 1/R2 + ... + 1/Rk)
                // Remove all edges between u and v
                remove all edges (u, v) from E
                // Add single edge with equivalent resistance
                add edge (u, v) with weight R_eq to E
                update graph G
            end if
        end for

        // Step 3: Check for trivial case
        if only edge is between s and t then
            return resistance(s, t)
        end if
    end while

    // Final check
    if |V| = 2 and edge exists between s and t then
        return resistance(s, t)
    else
        return "No valid path between s and t"
    end if
End Algorithm
</code></pre>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: The graph <span class="arithmatex">\( G \)</span> is input with nodes <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>. Edges have weights representing resistances.</li>
<li><strong>Series Reduction</strong>:</li>
<li>Identify nodes with degree 2 (excluding <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>), indicating two resistors connected in series.</li>
<li>Remove the node and its two edges, replacing them with a single edge whose weight is the sum of the resistances.</li>
<li><strong>Parallel Reduction</strong>:</li>
<li>Detect multiple edges between the same pair of nodes, indicating parallel resistors.</li>
<li>Replace them with a single edge whose weight is computed using the parallel formula.</li>
<li><strong>Iteration</strong>: Repeat series and parallel reductions until the graph reduces to one edge between <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>.</li>
<li><strong>Termination</strong>: Return the weight of the final edge as the equivalent resistance.</li>
</ul>
<h3 id="handling-nested-combinations">Handling Nested Combinations</h3>
<p>Nested configurations (e.g., resistors in series within a parallel branch) are handled naturally:
- <strong>Series within Parallel</strong>: A series chain may form a single edge that later combines in parallel with another edge. The algorithm first reduces the series chain, then detects the parallel edges in a subsequent iteration.
- <strong>Parallel within Series</strong>: Parallel edges may reduce to a single edge, which then forms part of a series chain. The iterative approach ensures all patterns are eventually simplified.
- The algorithm uses degree checks and edge multiplicity to identify reducible patterns without needing to explicitly classify nested structures, making it robust for arbitrary graphs.</p>
<h2 id="example-circuits">Example Circuits</h2>
<h3 id="example-1-simple-series-circuit">Example 1: Simple Series Circuit</h3>
<p><strong>Description</strong>: Three resistors <span class="arithmatex">\( R_1 = 2 \, \Omega \)</span>, <span class="arithmatex">\( R_2 = 3 \, \Omega \)</span>, <span class="arithmatex">\( R_3 = 5 \, \Omega \)</span> in series between nodes <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>.</p>
<p><strong>Graph</strong>:
- Nodes: <span class="arithmatex">\( s, A, B, t \)</span>
- Edges: <span class="arithmatex">\( (s, A, 2) \)</span>, <span class="arithmatex">\( (A, B, 3) \)</span>, <span class="arithmatex">\( (B, t, 5) \)</span></p>
<p><strong>Algorithm Steps</strong>:
1. Node <span class="arithmatex">\( A \)</span> has degree 2:
   - Edges <span class="arithmatex">\( (s, A, 2) \)</span>, <span class="arithmatex">\( (A, B, 3) \)</span>.
   - Remove <span class="arithmatex">\( A \)</span>, edges <span class="arithmatex">\( (s, A) \)</span>, <span class="arithmatex">\( (A, B) \)</span>.
   - Add edge <span class="arithmatex">\( (s, B, 2 + 3 = 5) \)</span>.
2. Node <span class="arithmatex">\( B \)</span> has degree 2:
   - Edges <span class="arithmatex">\( (s, B, 5) \)</span>, <span class="arithmatex">\( (B, t, 5) \)</span>.
   - Remove <span class="arithmatex">\( B \)</span>, edges <span class="arithmatex">\( (s, B) \)</span>, <span class="arithmatex">\( (B, t) \)</span>.
   - Add edge <span class="arithmatex">\( (s, t, 5 + 5 = 10) \)</span>.
3. Graph has one edge <span class="arithmatex">\( (s, t, 10) \)</span>.</p>
<p><strong>Result</strong>: Equivalent resistance = <span class="arithmatex">\( 10 \, \Omega \)</span>.</p>
<h3 id="example-2-simple-parallel-circuit">Example 2: Simple Parallel Circuit</h3>
<p><strong>Description</strong>: Two resistors <span class="arithmatex">\( R_1 = 4 \, \Omega \)</span>, <span class="arithmatex">\( R_2 = 6 \, \Omega \)</span> in parallel between <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>.</p>
<p><strong>Graph</strong>:
- Nodes: <span class="arithmatex">\( s, t \)</span>
- Edges: <span class="arithmatex">\( (s, t, 4) \)</span>, <span class="arithmatex">\( (s, t, 6) \)</span></p>
<p><strong>Algorithm Steps</strong>:
1. Detect multiple edges between <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>:
   - Resistances: <span class="arithmatex">\( 4 \, \Omega \)</span>, <span class="arithmatex">\( 6 \, \Omega \)</span>.
   - Parallel equivalent: <span class="arithmatex">\( R_{\text{eq}} = \frac{4 \cdot 6}{4 + 6} = \frac{24}{10} = 2.4 \, \Omega \)</span>.
   - Remove edges <span class="arithmatex">\( (s, t, 4) \)</span>, <span class="arithmatex">\( (s, t, 6) \)</span>.
   - Add edge <span class="arithmatex">\( (s, t, 2.4) \)</span>.
2. Graph has one edge <span class="arithmatex">\( (s, t, 2.4) \)</span>.</p>
<p><strong>Result</strong>: Equivalent resistance = <span class="arithmatex">\( 2.4 \, \Omega \)</span>.</p>
<h3 id="example-3-nested-configuration-series-parallel">Example 3: Nested Configuration (Series-Parallel)</h3>
<p><strong>Description</strong>: Two branches in parallel between <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>: one with a single resistor <span class="arithmatex">\( R_3 = 6 \, \Omega \)</span>, the other with two resistors <span class="arithmatex">\( R_1 = 2 \, \Omega \)</span>, <span class="arithmatex">\( R_2 = 3 \, \Omega \)</span> in series.</p>
<p><strong>Graph</strong>:
- Nodes: <span class="arithmatex">\( s, A, t \)</span>
- Edges: <span class="arithmatex">\( (s, A, 2) \)</span>, <span class="arithmatex">\( (A, t, 3) \)</span>, <span class="arithmatex">\( (s, t, 6) \)</span></p>
<p><strong>Algorithm Steps</strong>:
1. Node <span class="arithmatex">\( A \)</span> has degree 2:
   - Edges <span class="arithmatex">\( (s, A, 2) \)</span>, <span class="arithmatex">\( (A, t, 3) \)</span>.
   - Remove <span class="arithmatex">\( A \)</span>, edges <span class="arithmatex">\( (s, A) \)</span>, <span class="arithmatex">\( (A, t) \)</span>.
   - Add edge <span class="arithmatex">\( (s, t, 2 + 3 = 5) \)</span>.
2. Graph has two edges between <span class="arithmatex">\( s \)</span> and <span class="arithmatex">\( t \)</span>:
   - Edges: <span class="arithmatex">\( (s, t, 5) \)</span>, <span class="arithmatex">\( (s, t, 6) \)</span>.
   - Parallel equivalent: <span class="arithmatex">\( R_{\text{eq}} = \frac{5 \cdot 6}{5 + 6} = \frac{30}{11} \approx 2.727 \, \Omega \)</span>.
   - Remove edges <span class="arithmatex">\( (s, t, 5) \)</span>, <span class="arithmatex">\( (s, t, 6) \)</span>.
   - Add edge <span class="arithmatex">\( (s, t, 2.727) \)</span>.
3. Graph has one edge <span class="arithmatex">\( (s, t, 2.727) \)</span>.</p>
<p><strong>Result</strong>: Equivalent resistance ≈ <span class="arithmatex">\( 2.727 \, \Omega \)</span>.</p>
<h2 id="algorithm-efficiency-and-improvements">Algorithm Efficiency and Improvements</h2>
<h3 id="efficiency-analysis">Efficiency Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>:</li>
<li><strong>Series Reduction</strong>: Checking each node’s degree takes <span class="arithmatex">\( O(|V|) \)</span>. Removing a node and updating edges is <span class="arithmatex">\( O(1) \)</span> per reduction. At most <span class="arithmatex">\( |V| - 2 \)</span> nodes are removed, so series reductions contribute <span class="arithmatex">\( O(|V|^2) \)</span> in the worst case.</li>
<li><strong>Parallel Reduction</strong>: Checking for multiple edges involves examining all edge pairs, taking <span class="arithmatex">\( O(|E|^2) \)</span>. Each reduction is <span class="arithmatex">\( O(1) \)</span>, but multiple iterations may be needed.</li>
<li><strong>Iterations</strong>: The number of iterations depends on the graph structure. In the worst case (e.g., a complex graph), it’s proportional to <span class="arithmatex">\( |V| + |E| \)</span>.</li>
<li>Overall: <span class="arithmatex">\( O(|V|^2 + |E|^2) \)</span> per iteration, with potentially <span class="arithmatex">\( O(|V|) \)</span> iterations, leading to a rough estimate of <span class="arithmatex">\( O(|V|^3 + |E|^2 |V|) \)</span>.</li>
<li><strong>Space Complexity</strong>: <span class="arithmatex">\( O(|V| + |E|) \)</span> for storing the graph using an adjacency list or matrix.</li>
</ul>
<h3 id="potential-improvements">Potential Improvements</h3>
<ul>
<li><strong>Delta-Star Transformation</strong>: For graphs with cycles (e.g., Wheatstone bridge), series and parallel reductions may stall. Applying delta-star transformations can convert non-reducible subgraphs into reducible forms, though it increases complexity.</li>
<li><strong>Matrix Methods</strong>: Use the Laplacian matrix and Kirchhoff’s laws to compute equivalent resistance directly via linear algebra, which is more efficient for dense graphs (<span class="arithmatex">\( O(|V|^3) \)</span>).</li>
<li><strong>Priority Queue</strong>: Maintain a queue of reducible patterns (series nodes, parallel edges) to prioritize reductions, reducing unnecessary traversals.</li>
<li><strong>Graph Libraries</strong>: Leverage libraries like NetworkX (though not used here) for optimized graph operations in practice.</li>
</ul>
<h2 id="web-based-simulation-html-css-javascript">Web-Based Simulation (HTML, CSS, JavaScript)</h2>
<p>The simulation allows users to create a circuit graph by adding nodes and edges (resistors), select source and sink nodes, and compute the equivalent resistance by stepping through series and parallel reductions. The interface visualizes the graph and highlights reductions, with a bold and beautiful CSS design.</p>
<h3 id="code">Code</h3>
<p><strong>index.html</strong>:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Equivalent Resistance Simulator&lt;/title&gt;
    &lt;link rel="stylesheet" href="styles.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;Equivalent Resistance Simulator&lt;/h1&gt;
        &lt;div class="controls"&gt;
            &lt;button onclick="addNode()"&gt;Add Node&lt;/button&gt;
            &lt;button onclick="startAddEdge()"&gt;Add Resistor&lt;/button&gt;
            &lt;button onclick="setSource()"&gt;Set Source&lt;/button&gt;
            &lt;button onclick="setSink()"&gt;Set Sink&lt;/button&gt;
            &lt;button onclick="stepReduction()"&gt;Step Reduction&lt;/button&gt;
            &lt;button onclick="computeResistance()"&gt;Compute Resistance&lt;/button&gt;
            &lt;button onclick="reset()"&gt;Reset&lt;/button&gt;
            &lt;p&gt;Instructions: Click to add nodes, select nodes to add resistors, set source and sink, then step through reductions or compute directly.&lt;/p&gt;
            &lt;p&gt;Equivalent Resistance: &lt;span id="result"&gt;N/A&lt;/span&gt; Ω&lt;/p&gt;
        &lt;/div&gt;
        &lt;canvas id="circuitCanvas" width="800" height="600"&gt;&lt;/canvas&gt;
    &lt;/div&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>styles.css</strong>:</p>
<pre><code class="language-css">* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1e3c72, #2a5298);
    color: #ffffff;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
}

.container {
    text-align: center;
    background: rgba(255, 255, 255, 0.1);
    padding: 40px;
    border-radius: 20px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
}

h1 {
    font-size: 3.5em;
    margin-bottom: 30px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    color: #ffd700;
}

.controls {
    margin-bottom: 30px;
}

.controls button {
    font-size: 1.8em;
    padding: 15px 30px;
    margin: 10px;
    border: none;
    border-radius: 10px;
    background: #ff6f61;
    color: #ffffff;
    cursor: pointer;
    transition: transform 0.2s, background 0.3s;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.controls button:hover {
    background: #ff3d2e;
    transform: scale(1.05);
}

.controls p {
    font-size: 1.6em;
    margin: 15px 0;
    color: #e0e0e0;
}

#circuitCanvas {
    border: 5px solid #ffffff;
    border-radius: 15px;
    background: #ffffff;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
}
</code></pre>
<p><strong>script.js</strong>:</p>
<pre><code class="language-javascript">const canvas = document.getElementById('circuitCanvas');
const ctx = canvas.getContext('2d');
const resultSpan = document.getElementById('result');

let nodes = [];
let edges = [];
let source = null, sink = null;
let addingEdge = false;
let firstNode = null;

function addNode() {
    const x = Math.random() * (canvas.width - 40) + 20;
    const y = Math.random() * (canvas.height - 40) + 20;
    nodes.push({ x, y, id: nodes.length });
}

function startAddEdge() {
    addingEdge = true;
    firstNode = null;
    alert('Click first node for resistor.');
}

function setSource() {
    alert('Click node to set as source.');
    canvas.onclick = (e) =&gt; {
        const node = getNodeAt(e.offsetX, e.offsetY);
        if (node) {
            source = node.id;
            canvas.onclick = null;
            draw();
        }
    };
}

function setSink() {
    alert('Click node to set as sink.');
    canvas.onclick = (e) =&gt; {
        const node = getNodeAt(e.offsetX, e.offsetY);
        if (node) {
            sink = node.id;
            canvas.onclick = null;
            draw();
        }
    };
}

function getNodeAt(x, y) {
    return nodes.find(n =&gt; Math.hypot(n.x - x, n.y - y) &lt; 15);
}

canvas.onclick = (e) =&gt; {
    if (addingEdge) {
        const node = getNodeAt(e.offsetX, e.offsetY);
        if (node) {
            if (!firstNode) {
                firstNode = node;
                alert('Click second node.');
            } else if (firstNode.id !== node.id) {
                const resistance = prompt('Enter resistance (Ω):');
                if (resistance &amp;&amp; !isNaN(resistance) &amp;&amp; resistance &gt; 0) {
                    edges.push({ u: firstNode.id, v: node.id, R: parseFloat(resistance) });
                    addingEdge = false;
                    firstNode = null;
                    canvas.onclick = null;
                    draw();
                }
            }
        }
    }
};

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    edges.forEach(e =&gt; {
        const u = nodes[e.u], v = nodes[e.v];
        ctx.beginPath();
        ctx.moveTo(u.x, u.y);
        ctx.lineTo(v.x, v.y);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 4;
        ctx.stroke();
        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText(`${e.R}Ω`, (u.x + v.x) / 2, (u.y + v.y) / 2);
    });
    nodes.forEach(n =&gt; {
        ctx.beginPath();
        ctx.arc(n.x, n.y, 10, 0, 2 * Math.PI);
        ctx.fillStyle = n.id === source ? 'red' : n.id === sink ? 'blue' : 'green';
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.stroke();
    });
}

function getDegree(nodeId) {
    return edges.filter(e =&gt; e.u === nodeId || e.v === nodeId).length;
}

function stepReduction() {
    if (source === null || sink === null) {
        alert('Set source and sink nodes.');
        return;
    }

    // Series reduction
    for (let i = 0; i &lt; nodes.length; i++) {
        if (nodes[i].id !== source &amp;&amp; nodes[i].id !== sink &amp;&amp; getDegree(nodes[i].id) === 2) {
            const es = edges.filter(e =&gt; e.u === nodes[i].id || e.v === nodes[i].id);
            if (es.length === 2) {
                let u = es[0].u === nodes[i].id ? es[0].v : es[0].u;
                let v = es[1].u === nodes[i].id ? es[1].v : es[1].u;
                const R_eq = es[0].R + es[1].R;
                edges = edges.filter(e =&gt; e !== es[0] &amp;&amp; e !== es[1]);
                edges.push({ u, v, R: R_eq });
                nodes.splice(i, 1);
                nodes.forEach((n, idx) =&gt; n.id = idx);
                if (source &gt; nodes[i].id) source--;
                if (sink &gt; nodes[i].id) sink--;
                draw();
                return;
            }
        }
    }

    // Parallel reduction
    for (let u = 0; u &lt; nodes.length; u++) {
        for (let v = u + 1; v &lt; nodes.length; v++) {
            const parallelEdges = edges.filter(e =&gt; 
                (e.u === nodes[u].id &amp;&amp; e.v === nodes[v].id) || 
                (e.u === nodes[v].id &amp;&amp; e.v === nodes[u].id)
            );
            if (parallelEdges.length &gt; 1) {
                const R_eq = 1 / parallelEdges.reduce((sum, e) =&gt; sum + 1 / e.R, 0);
                edges = edges.filter(e =&gt; !parallelEdges.includes(e));
                edges.push({ u: nodes[u].id, v: nodes[v].id, R: R_eq });
                draw();
                return;
            }
        }
    }

    alert('No reductions possible or circuit is solved.');
}

function computeResistance() {
    if (source === null || sink === null) {
        alert('Set source and sink nodes.');
        return;
    }

    let tempNodes = nodes.map(n =&gt; ({ ...n }));
    let tempEdges = edges.map(e =&gt; ({ ...e }));
    let tempSource = source, tempSink = sink;

    while (tempNodes.length &gt; 2 || tempEdges.length &gt; 1) {
        let reduced = false;

        // Series
        for (let i = 0; i &lt; tempNodes.length; i++) {
            if (tempNodes[i].id !== tempSource &amp;&amp; tempNodes[i].id !== tempSink &amp;&amp; getDegree(tempNodes[i].id, tempEdges) === 2) {
                const es = tempEdges.filter(e =&gt; e.u === tempNodes[i].id || e.v === tempNodes[i].id);
                if (es.length === 2) {
                    let u = es[0].u === tempNodes[i].id ? es[0].v : es[0].u;
                    let v = es[1].u === tempNodes[i].id ? es[1].v : es[1].u;
                    const R_eq = es[0].R + es[1].R;
                    tempEdges = tempEdges.filter(e =&gt; e !== es[0] &amp;&amp; e !== es[1]);
                    tempEdges.push({ u, v, R: R_eq });
                    tempNodes.splice(i, 1);
                    tempNodes.forEach((n, idx) =&gt; n.id = idx);
                    if (tempSource &gt; tempNodes[i].id) tempSource--;
                    if (tempSink &gt; tempNodes[i].id) tempSink--;
                    reduced = true;
                    break;
                }
            }
        }

        if (reduced) continue;

        // Parallel
        for (let u = 0; u &lt; tempNodes.length; u++) {
            for (let v = u + 1; v &lt; tempNodes.length; v++) {
                const parallelEdges = tempEdges.filter(e =&gt; 
                    (e.u === tempNodes[u].id &amp;&amp; e.v === tempNodes[v].id) || 
                    (e.u === tempNodes[v].id &amp;&amp; e.v === tempNodes[u].id)
                );
                if (parallelEdges.length &gt; 1) {
                    const R_eq = 1 / parallelEdges.reduce((sum, e) =&gt; sum + 1 / e.R, 0);
                    tempEdges = tempEdges.filter(e =&gt; !parallelEdges.includes(e));
                    tempEdges.push({ u: tempNodes[u].id, v: tempNodes[v].id, R: R_eq });
                    reduced = true;
                    break;
                }
            }
            if (reduced) break;
        }

        if (!reduced) {
            resultSpan.textContent = 'Cannot reduce further';
            return;
        }
    }

    const finalEdge = tempEdges.find(e =&gt; 
        (e.u === tempSource &amp;&amp; e.v === tempSink) || 
        (e.u === tempSink &amp;&amp; e.v === tempSource)
    );
    if (finalEdge) {
        resultSpan.textContent = finalEdge.R.toFixed(3);
    } else {
        resultSpan.textContent = 'No path';
    }
}

function getDegree(nodeId, edgesList = edges) {
    return edgesList.filter(e =&gt; e.u === nodeId || e.v === nodeId).length;
}

function reset() {
    nodes = [];
    edges = [];
    source = null;
    sink = null;
    resultSpan.textContent = 'N/A';
    draw();
}

draw();
</code></pre>
<h3 id="explanation-of-the-web-simulation">Explanation of the Web Simulation</h3>
<ul>
<li><strong>HTML</strong>:</li>
<li>A canvas for drawing the circuit graph.</li>
<li>Buttons for adding nodes, resistors, setting source/sink, stepping through reductions, computing resistance, and resetting.</li>
<li>
<p>Displays the equivalent resistance.</p>
</li>
<li>
<p><strong>CSS</strong>:</p>
</li>
<li>Uses a gradient background for depth.</li>
<li>Large, bold fonts (e.g., 3.5em for the title, 1.8em for buttons) for readability.</li>
<li>Buttons have hover effects (scale, color change) and shadows for a modern look.</li>
<li>Canvas has a white background with a rounded border and shadow for emphasis.</li>
<li>
<p>Glassmorphism effect on the container (blur, transparency) enhances aesthetics.</p>
</li>
<li>
<p><strong>JavaScript</strong>:</p>
</li>
<li><strong>Nodes</strong>: Added randomly on the canvas, drawn as colored circles (red for source, blue for sink, green otherwise).</li>
<li><strong>Edges</strong>: Added by selecting two nodes and entering a resistance value, drawn as lines with resistance labels.</li>
<li><strong>Reductions</strong>:<ul>
<li><strong>Series</strong>: Finds a node with degree 2 (not source or sink), removes it, and combines the resistances.</li>
<li><strong>Parallel</strong>: Finds multiple edges between two nodes and computes the parallel equivalent.</li>
<li><strong>Step Reduction</strong>: Performs one reduction and redraws the graph, highlighting changes.</li>
</ul>
</li>
<li><strong>Compute Resistance</strong>: Runs reductions until the graph is a single edge, displaying the result.</li>
<li><strong>Interactivity</strong>: Click-based node selection, prompts for resistance values, and visual feedback ensure usability.</li>
</ul>
<h3 id="features">Features</h3>
<ul>
<li><strong>Interactive Graph Building</strong>: Users can place nodes and connect them with resistors.</li>
<li><strong>Step-by-Step Reduction</strong>: Visualizes each series or parallel simplification, aiding understanding.</li>
<li><strong>Direct Computation</strong>: Computes the final resistance in one click.</li>
<li><strong>Visual Feedback</strong>: Color-coded nodes and labeled edges clarify the circuit structure.</li>
<li><strong>Reset Option</strong>: Clears the canvas for new circuits.</li>
</ul>
<h3 id="testing-with-examples">Testing with Examples</h3>
<p>Users can recreate the example circuits:
- <strong>Series</strong>: Add nodes <span class="arithmatex">\( s, A, B, t \)</span>, connect <span class="arithmatex">\( s-A \)</span>, <span class="arithmatex">\( A-B \)</span>, <span class="arithmatex">\( B-t \)</span>, and compute <span class="arithmatex">\( 10 \, \Omega \)</span>.
- <strong>Parallel</strong>: Add nodes <span class="arithmatex">\( s, t \)</span>, add two edges with <span class="arithmatex">\( 4 \, \Omega \)</span>, <span class="arithmatex">\( 6 \, \Omega \)</span>, and compute <span class="arithmatex">\( 2.4 \, \Omega \)</span>.
- <strong>Nested</strong>: Add nodes <span class="arithmatex">\( s, A, t \)</span>, connect <span class="arithmatex">\( s-A \)</span>, <span class="arithmatex">\( A-t \)</span>, and <span class="arithmatex">\( s-t \)</span>, and compute <span class="arithmatex">\( 2.727 \, \Omega \)</span>.</p>
<h2 id="deliverables-summary">Deliverables Summary</h2>
<ol>
<li><strong>Algorithm Description and Pseudocode</strong>: Provided with clear steps for series and parallel reductions.</li>
<li><strong>Explanation of Examples</strong>:</li>
<li>Simple series: Reduced to <span class="arithmatex">\( 10 \, \Omega \)</span>.</li>
<li>Simple parallel: Reduced to <span class="arithmatex">\( 2.4 \, \Omega \)</span>.</li>
<li>Nested series-parallel: Reduced to <span class="arithmatex">\( 2.727 \, \Omega \)</span>.</li>
<li><strong>Efficiency Analysis</strong>: Estimated complexity and suggested improvements like delta-star or matrix methods.</li>
<li><strong>Web Simulation</strong>: Interactive HTML/CSS/JavaScript project visualizing circuit simplification, with bold and beautiful CSS styling.</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>The graph theory approach simplifies equivalent resistance calculations by iteratively reducing series and parallel patterns, handling even nested configurations effectively. The web simulation makes this process accessible and educational, allowing users to build, simplify, and analyze circuits interactively. The bold, visually appealing design enhances user engagement, making the physics of circuits both understandable and enjoyable.</p>
<hr/>
<p>To run the simulation, save the HTML, CSS, and JavaScript files in a directory and open <code>index.html</code> in a browser. Let me know if you need additional features (e.g., support for delta-star transformations), specific circuit presets, or further assistance!</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
